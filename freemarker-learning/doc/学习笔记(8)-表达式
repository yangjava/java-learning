##  表达式
简介

当需要给插值或者指令参数提供值时，可以使用变量或其他复杂的表达式。
例如，我们 设 x 为 8，y 为 5，那么(x+y)/2 的值就会被处理成数字类型的值 6.5
在我们展开细节之前，先来看一些具体的例子：
 当给插值提供值时：插值的使用方式为${expression}，把它放到你想输出文 本的位置上然后给值就可以打印了。
        即${(5+8)/2}会打印”6.5”出来（如果输出 的语言不是英语，也可能打印出”6,5”）。
 当给指令参数提供值时：在入门章节我们已经看到 if 指令的使用了。这个指令的语 法是：<#if expression>...</#if>。
这里的表达式计算结果必须是布 尔类型的。比如<#if 2 < 3>中的 2 < 3（2 小于 3）是结果为 true 的布尔 表达式。

快速浏览（备忘单）

这里是给已经了解 FreeMarker 的人或有经验的程序员的一个提醒：
		直接指定值
		字符串： "Foo" 或者 'Foo' 或者 "It's \"quoted\"" 或者 
		r"C:\raw\string"
		数字：123.45

		布尔值：true, false
		序列：["foo", "bar", 123.45], 1..100
		哈希表：{"name":"green mouse", "price":150}
		检索变量
		顶层变量：user
		从哈希表中检索数据：user.name, user[“name”]
		从序列中检索：products[5]
		特殊变量：.main
		字符串操作
		插值（或连接）："Hello ${user}!"（或"Free" + "Marker"）
		获取一个字符：name[0]
		序列操作
		连接：users + ["guest"]
		序列切分：products[10..19] 或 products[5..]
		哈希表操作
		连接：passwords + {"joe":"secret42"}
		算数运算: (x * 1.5 + 10) / 2 - y % 100
		比较 运算 ： x == y,  x != y,  x < y,  x > y,  x >= y,  x <= y, x &lt; y, 等等
		逻辑操作：!registered && (firstVisit || fromEurope)
		内建函数：name?upper_case
		方法调用：repeat("What", 3)
		处理不存在的值
		默认值：name!"unknown" 或者(user.name)!"unknown" 或者
		name! 或者 (user.name)!
		检测不存在的值：name?? 或者(user.name)?? 参考：运算符的优先级

##  直接确定值
     通常我们喜欢是使用直接确定的值而不是计算的结果。

## 字符串

在文本中确定字符串值的方法是看引号和单引号，比如"some text" 或'some text'，这两种形式是相等的。
如果文本本身包含用于字符引用的引号（双引号”或单引 号’）或反斜杠时，应该在它们的前面再加一个反斜杠，这就是转义。
转义允许你直接在文 本中输入任何字符，也包括反斜杠。例如：

${"It's \"quoted\" and this is a backslash: \\"}

${'It\'s "quoted" and this is a backslash: \\'}

输出为：

It's  "quoted"  and this is a backslash: \

It's  "quoted"  and this is a backslash: \

注意： 这里当然可以直接在模板中输入文本而不需要${…}。但是我们在这里用它只是为了示例
来说明表达式的使用。
下面的表格是 FreeMarker 支持的所有转义字符。在字符串使用反斜杠的其他所有情况 都是错误的，运行这样的模板都会失败。

都是错误的，运行这样的模板都会失败。

转义序列	含义
\	引号（u0022）
\’	单引号（又称为撇号）（u0027）
\\	反斜杠（u005C）
\n	换行符（u000A）
\r	回车（u000D）
\t	水平制表符（又称为标签）（u0009）
\b	退格（u0008）
\f	换页（u000C）
\l	小于号：<
\g	大于号：>
\a	和号：&

\xCode	字符的 16 进制 Unicode 码（UCS 码）
在\x 之后的 Code 是 1-4 位的 16 进制码。下面这个示例中都是在字符串中放置版权
符号"\xA9 1999-2001",  "\x0A9 1999-2001",  "\x00A9 1999-2001"：
如果紧跟 16   进制码后一位的字符也能解释成 16  进制码时，就必须把 4 位补全，否则
FreeMarker 的解析就会出现问题。 注意字符序列${（#{）有特殊的含义，它们被用做插入表达式的数值（典型的应用是：
"Hello ${user}!"）。这将在后续章节中解释。如果想要打印${，就要使用下面所说
的原生字符串。 一种特殊的字符串就是原生字符串。在原生字符串中，反斜杠和${没有特殊的含义，
它们被视为普通的字符。为了表明字符串是原生字符串，在开始的引号或单引号之前放置字
母 r，例如：

${r"${foo}"}
${r"C:\foo\bar"}

将会打印：

${foo} C:\foo\bar

##　　　数字

输入不带引号的数字就可以直接指定一个数字，必须使用点作为小数的分隔符而不能是 其他的分组分隔符。
可以使用-或+来表明符号（+ 是多余的）。科学记数法暂不支持使用（1E3 就是错误的），
而且也不能在小数点之前不写 0（.5 也是错误的）。
下面的数字都是合法的：0.08, -5.013, 8, 008, 11, +11。
数值文字 08, +8, 8.00 和 8 是完全相等的，它们都是数字 8。因此${08}, ${+8},
${8.00}和${8}打印的都是相同的。


## 　布尔值　
直接写 true 或 false 就表征一个布尔值了，不需使用引号。

##　　序列

指定一个文字的序列，使用逗号来分隔其中的每个子变量，然后把整个列表放到方括号 中。例如：

<#list ["winter", "spring", "summer", "autumn"] as x>
${x}
</#list>

将会打印出：
winter 
spring 
summer 
autumn

列 表 中 的 项目 是 表达 式 ，那 么 也 可以 这 样做 ： [2 + 2, [1, 2, 3, 4], "whatnot"]，
其中第一个子变量是数字 4，第二个子变量是一个序列，第三个子变量是 字符串”whatnot”。
也可以用 start..end 定义存储数字范围的序列，这里的 start 和 end 是处理数 字值表达式，
比如 2..5 和[2, 3, 4, 5]是相同的，但是使用前者会更有效率（内存 占用少而且速度快）。
可以看出前者也没有使用方括号，这样也可以用来定义递减的数字范
围，比如 5..2。（此外，还可以省略 end，只需 5..即可，但这样序列默认包含 5,6,7,8
等递增量直到无穷大）

## 　哈希表

在模板中指定一个哈希表，就可以遍历用逗号分隔开的“键/值”对，把列表放到花括 号内。
键和值成对出现并以冒号分隔。看这个例子：{"name":"green mouse", "price":150}。
注意到名字和值都是表达式，但是用来检索的名字就必须是字符串类型的。

##  检索变量

## 顶层变量

为了访问顶层的变量，可以简单地使用变量名。
例如，用表达式 user 就可以在根上 获取以“user”为名存储的变量值。然后就可以打印出存储在里面的内容。

${user}

如果没有顶层变量，那么 FreeMarker 在处理表达式时就会发生错误，进而终止模板的 执行（除非程序员事先配置了 FreeMarker）。
在这个表达式中变量名可以包含字母（也可以是非拉丁文），数字（也可以是非拉丁数 字），下划线(_)，美元符号($)，at  符号(@)和哈希表(#)，
此外要注意变量名命名时是不能以 数字开头的。

## 从哈希表中检索数据

如果有一个表达式的结果是哈希表，那么我们可以使用点和子变量的名字得到它的值， 假设我们有如下的数据模型：
(root)
|
+- book
|	|
|	+- title = "Breeding green mouses"
|	|
|	+- author
|	|
|	+- name = "Julia Smith"
|	|
|	+- info = "Biologist, 1923-1985,  Canada"
|
+- test = "title"

现在，就可以通过 book.title 来读取 title 表达式，book 将返回一个哈希表（就 像 上 一 章 中 解 释 的 那 样 ）。 
按 这 种 逻 辑 进 一 步 来 说 ， 我 们 可 以 使 用 表 达 式 book.author.name 来读取到 auther 的 name。
如果我们想 指定 同一个表达式 的 子变量，那么还有 另外一种语法格式 ：
book["title"]。在方括号中可以给出任意长度字符串的表达式。
在上面这个数据模型 示例中你还可以这么来获取 title：book[test] ，
下面这些示例它们含义都是相等的：
 book.author.name, book["author"].name, book.author.["name"], book["author"]["name"]。

当使用点式语法时，顶层变量名的命名也有相同的限制（命名时只能使用字母，数字， 下划线，$，@等），
而使用方括号语法形式时命名有没有这样的限制，它可以是任意的表达 式。（为了 FreeMarker  支持 XML，
如果变量名是*（星号）或者**，那么就应该使用方括号 语法格式。）
对于顶层变量来说，如果尝试访问一个不存在的变量也会引起错误导致模板解析执行的 中断（除非程序员事先配置过 FreeMarker）。


从序列中检索数据

这和从哈希表中检索是相同的，但是你只能使用方括号语法形式来进行，而且方括号内 的表达式最终必须是一个数字而不是字符串。
在第一章的数据模型示例中，为了获取第一个 动物的名字（记住第一项数字索引是 0 而不是 1）可以这么来写：animals[0].name。

 特殊变量

特殊变量是由 FreeMarker 引擎本身定义的，为了使用它们，可以按照如下语法形式来 进行：.variable_name。
通常情况下是不需使用特殊变量，而对专业用户来说可能用到。所有特殊变量的说明可
以参见参考手册。








