接着上篇《JVM源码分析之Java对象的创建过程》，本文对Java对象的内存分配过程进行深入分析，其中有以下几种分配方式：
1、从线程的局部缓冲区分配临时内存
2、从内存堆中分配临时内存
3、从内存堆中分配永久内存

新建一个对象时，由对应的instanceKlass对象计算出需要多大的内存，并调用CollectedHeap的common_mem_allocate_noinit方法分配指定大小的内存，实现如下：


从线程的局部缓冲区分配临时内存

TLAB技术是每个线程在Java堆中预先分配了一小块内存，当有对象创建请求内存分配时，就会在该块内存上进行分配，而不需要在Java堆通过同步控制进行内存分配。如果UseTLAB为真，则使用TLAB技术（Thread-Local Allocation Buffers），将分配工作交由线程自行完成，实现如下：


1、如果线程的局部缓冲区可以分配指定大小的内存，则直接分配；
2、否则执行allocate_from_tlab_slow在Java堆上进行分配，实现如下：


3、通过allocate_new_tlab从Java堆上重新为线程分配一块局部缓冲区，实现如下：


其中mem_allocate方法实现从Java堆分配临时内存。

从内存堆中分配临时内存

在内存堆管理器看来，为普通对象分配内存和为某一线程分配一块本地分配缓冲区在本质上都是一样的，这块内存都是临时的，只能从新生代或老年代中进行分配，通过gc策略GenCollectorPolicy::mem_allocate_work方法进行实现，大概步骤如下：

step 1


1、gch->no_gc_in_progress()确保当前JVM没有正在进行gc；
2、参数gc_overhead_limit_was_exceeded表示当前内存分配操作是否发生了gc，以及gc耗时是否超过设置限制，主要针对一些对延迟敏感的场景，当该参数为true时，抛出OOM的异常给上层；

step 2


通过重试机制确保内存能够分配成功：
1、首先在新生代采用无锁的方式尝试分配内存，通过Atomic::cmpxchg_ptr的CAS操作对新生代空闲内存进行同步分配，最终实现如下：


2、如果分配失败，则执行step 3；

step 3


1、如果在新生代中内存分配失败，则通过加锁方式进行分配；
2、参数first_only表示当前是否只应该在新生代分配内存，如果新生代的剩余空间不够，则尝试在老年代进行分配；
3、依次尝试从内存各个代中分配内存，实现如下：


4、如果内存分配成功，则返回，否则执行step 4；

step 4


1、gc_locker::is_active_and_needs_gc()为真时，表示当前其它线程已经触发了gc；
2、如果is_tlab为真，表示当前线程正在为局部分配缓冲区申请内存；
3、如果!gch->is_maximal_no_gc()为真，表示新生代或老年代可以进行内存扩展，扩展完成后，再次尝试从各代中进行分配，实现如下：


4、如果内存扩展之后还是没有足够的内存满足分配需求，则执行step 5；

step 5


如果当前线程没有位于jni的临界区，将释放Java堆的互斥锁，以使得请求gc的线程可以进行gc操作，等所有本地线程退出临界区和gc完成后，将继续循环尝试分配内存。

step 6


1、如果各代无法分配对象的内存，说明需要触发一次gc操作，提交VM一个GenCollectForAllocation操作，最终由名为VM Thread的JVM级线程调度执行；
2、当操作执行成功并返回时，如果gc锁已被加锁，说明已经由其它线程触发了gc，则继续循环以等待gc完成；
3、否则当前线程等待gc完成，判断gc耗时是否超过设置的gc超时上限，并执行软引用的清除；
4、如果gc超时，则给上层调用返回NULL，让其抛出内存溢出错误；

作者：占小狼
链接：http://www.jianshu.com/p/e56c808b6c8a
來源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。