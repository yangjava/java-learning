前言

在日常的开发过程中，我们通过会使用Thread.sleep模拟一个耗时的任务执行过程。

线程sleep或yield之后发生了什么？在深入细节之前，先看看线程的基本概念。

线程概念

线程是操作系统执行任务的基本单位，处理器的数量决定了不可能所有的线程同时得到运行，这就意味着需要通过某种算法，如window下的抢占式，进行线程的调度。


Paste_Image.png

一个线程从开始到结束可能会有上述几种状态，之间可以互相转换。

Thread.sleep

Sleep意味着线程主动告诉操作系统自己要休息 n 毫秒。

Thread.sleep(0) 进入就绪状态
如果n=0时，意味着当前线程的时间片没有用完，主动放弃自己剩下的时间片，进入就绪状态。这种情况下只能调度优先级相等或更高的线程，意味着优先级低的线程很难获得时间片，很可能永远都调用不到。当没有符合条件的线程，会一直占用 CPU 时间片，造成 CPU 100%占用率。
Thread.sleep(1) 进入阻塞状态
如果n>0，会强制当前线程放弃剩余时间片，并休息n秒（因为不是实时操作系统，时间无法保证精确，一般可能会滞后几毫秒或一个时间片），进入阻塞状态。这种情况下所有其它就绪状态的线程都有机会竞争时间片，而不用在乎优先级。无论有没有符合的线程，都会放弃 CPU 时间，因此 CPU 占用率较低。
Thread.yield

Yield 的中文翻译为 “让步，让位”，这里意思是当前线程主动让出时间片，并让操作系统调度其它就绪态的线程使用时间片。

如果调用 Yield，只是把当前线程放入到就绪队列中，而不是阻塞队列
如果没有找到其它就绪态的线程，则当前线程继续运行
比 Thread.Sleep(0) 速度要快，可以让低于当前优先级的线程得以运行

