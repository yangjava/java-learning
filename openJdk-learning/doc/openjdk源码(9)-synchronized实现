在java多线程编程中，控制并发访问可以通过加锁或采用原子变量的方式。

juc下给我们提供的显示的lock，查看AQS源码我们可以知道，aqs实现原理简单理解就是构造了一个等待队列，当持有锁的线程在释放锁的时刻去唤醒队列中的某一个线程(公平)。

java中还有一种内置锁 通过synchronized关键字来实现，synchronized 修饰方法时，锁住的是当前对象；修饰代码块时，锁住的是括号内的对象；修饰static方法，锁住的是当前Class，但具体的synchronized实现原理我们通过jdk的源码查看不到，只能去翻jvm的源码了。

 

在openjdk的wiki上有介绍synchronized的实现原理，这里借用网站的图来简单分析一下.

左侧偏向锁，右侧禁用偏向锁



 

在jvm里解析的时候，每个对象都有一个header，用来存放和锁相关的元素.

hashcode + generation + 偏向标记+锁状态  

偏向标记  1 ：偏向，0：无偏向 

锁状态  01：无锁 ， 00 ： 轻量级锁  ，10：重量级锁

锁的升级是从  偏向锁 > 轻量锁 > 重量锁， 不可降级

说了上面的基本概念后下面开始看看上面这个图，分析一下synchronized具体是如果做到的.

 

当对象处于无锁状态时,对象头的后两位为01，当线程T1进入代码块时JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，jvm尝试通过cas操作将Mark word指向自己锁记录指针 . 若成功当前线程将持有锁, 后两位修改为00；如果cas操作失败，则说明次对象已被线程持有，此时jvm将检查对象头中的线程指针是否指向当前线程，若是则继续执行（重入）；若不是，表明此时有多个线程同时进入代码块，发生竞争，T1自旋尝试获取锁.  自旋一定次数或时间(待确定)后，锁将升级为重量级锁

 

轻量级解锁时，会使用原子的CAS操作来将当前线程栈帧的Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁 