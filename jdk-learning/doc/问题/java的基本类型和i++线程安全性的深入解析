在java中，除了long和double的8个字节、64位比特的变量外，其他的基本变量都是原子性的。

java存储模型要求获取和存储操作都为原子性，但是对于非volatile的long和double变量，jvm允许将64位的读或写划分为两个32位的操作。

如果读和写发生在不同的线程，这种情况读取一个非volatile类型long就可能会出现得到一个值的高32位和另一个值的低32位。

因此，即使你并不关心过期数据，但仅仅在多线程程序中使用共享的、可变的long和double变量也可能是不安全的，除非将它们声明为volatile，或者用锁保护起来。

说起原子性的操作，是指读和写是原子性的，比如i=5;这个就是一个原子性的操作。

但是两个原子性的操作合在一起进行，就不一定是原子性的了，比如先读后写，那么就有可能在读之后这个变量被修改过。

i++就是这样的一个操作，先读后写，所以说整型变量是原子性的，不是说i++就是一个原子性的操作。

当你使用for(int i=0; i<10000; i++){System.out.print(i)}

你会发现，i到最后不会打印出10000，打印出8-9千左右。

但是在多线程的情况下，就算整型变量是原子性的，也有可能会出现线程安全的问题，这个是线程可见性的问题，所以需要加上volatile声明才行，

该修饰符是强制变量每次从内存中读取，而不会存储在寄存器中。