上一篇文章使用微服务架构重构支付网关 是从横向的角度来分析如何分解服务以及建立微服务之间的关系。这篇文章从纵向详细介绍如何对SSH框架的支付系统实施具体的技改。这里不涉及具体代码写法，重点在于说明方法论。虽然以SSH(Apache Struts + Springframework + Hibernate) 框架为例，也适合各种常用的web架构 (Apache Struts/Spring MVC / Apache Velocity + Springframework + Mybatis/Hibernate) 。

选取入手模块
如果遗留系统规模庞大，那应该如何挑选入手点？以支付系统为例，如前文所述，支付系统一般包括账户，交易，订单，优惠券，钱包，支付渠道，清结算，支付网关，运营系统等模块。模块很多，如何选择突破点？ 我们采取的方法是寻找对外依赖最小的模块，由此开始调整。 首先模块依赖关系整理出来。 Image of Portal System 从上图可以看出来，账户系统在依赖树中是处于树根的位置，对它的调整相对容易。只要保持对外接口不变即可。

重构策略
重构如同飞行中更换引擎，必须非常小心，我们采取的策略是:小步快跑，积小胜为大胜。

每一个改进点，需在1~3天内完成，不能超过一个周。
每次改进，均可直接上线运行，不需要长时间的AB测试。
在功能也就是对外接口不变的前提下，开始进行拆分工作。 在结构上，原SSH系统是一个大项目，所有代码分层分模块堆在一起。微服务系统需要将它们拆分。直观的拆分方法是按层，按模块同构的拆分成各个独立运行和维护的系统。由此带来了一系列的调整。在SSH架构下，重构可以采用自上而下的方法进行，这样可以确保每一层的重构都有明确的输入输出，并且是可测试的。 gateway steps 整体上，重构分为三个步骤：
参考原有系统的DAO层和业务逻辑层，实现基础服务，一般是使用RPC来实现.
将对外的接口层进行重构，调整为调用RPC服务。
将原有服务切一部分流量到新服务上进行试运行。
试运行成功，全部流量都切过来。 旧服务废弃。
API网关
在SSH架构下，对API网关一般是通过NGINX的rewtite模块来实现，逻辑简单，人工维护即可。而一旦接口层按照业务来拆分后，网关路由逻辑复杂多了，通过人工维护配置文件难度激增，需要调整成自动注册更新路由的方式。也就是每个服务需要将自己提供的服务和API注册到API网关上， API网关需要自动识别并加载新的路由。

针对这个需求，我们开发了一个connector， 其工作原理如下： Image of Portal System

服务在启动完成后，注册到zookeeper上。
connector监听 zookeeper，一旦有变更，则获取服务列表，更新nginx.conf文件
connector在更新完成nginx.conf文件后，执行nginx的reload命令，让配置生效。
load balancer 将服务打到nginx上，nginx可以按照新配置来执行服务路由。
在服务关闭时，执行类似的操作。第一步是在服务关闭前，将服务从zookeeper上删除。注意必须在服务关闭前删除，否则会发生服务不可用的错误。 服务注册项从zookeeper上删除，并且本地服务没有流量后，才能关闭服务。connector可以和nginx部署在同一台机器上。

服务接口调整
使用Spring MVC实现的Controller或者使用Apache Struts实现的Action，需要按照业务进行组合，拆分到具体项目中，原则上，一个项目不应该有超过5个接口，避免接口过于复杂。本次调整需要做的工作包括：

增加服务注册机制，在服务启动时将服务注册到zookeeper上；
增加服务退出机制，在服务关闭时将服务解除注册；
将服务按照业务组合，建立对应的项目；
将服务依赖的业务逻辑层打包到同一个jar中，作为后续改进的基础。
服务上线，替换掉现有的服务。
业务逻辑层调整
在springframework框架下，业务逻辑层被实现为服务层和DAO层之间的桥梁。 对于绝大多数应用来说，业务逻辑层都是非常薄的一层封装，调整为微服务架构下，业务逻辑层有三种处理方式:

抽象为独立的RPC服务，对于功能比较复杂业务逻辑，可以使用这种方式。
下沉到DAO层，如果逻辑上涉及数据访问操作多，或者需要事务处理的，可以合并到DAO中，一同实现为RPC。
上浮到接口层。如果业务逻辑比较简单，也可以上浮。
DAO层的重构
DAO层的重构的工作量比较大。 需要将原来访问数据库的逻辑，调整为远程RPC调用：

针对DAO的接口，开发RPC服务，将数据访问逻辑通过RPC来隔离；
提供DAO的RPC接口客户端，替换原DAO服务接口的实现。 
这样在业务逻辑层和服务层中调用的DAO，调整为RPC调用，将数据访问逻辑和业务逻辑分离。这样在DAO层就可以根据业务需要选用合适的存储数据库。
性能优化
完成上述调整，这才是万里长征走完的第一步。接下来就是码农们最心爱的性能优化了。 对于大部分线上应用来说，性能优化主要的工作是选择合适的存储介质来满足性能的需求。

数据可以直接写入MySQL或者其他的持久化存储。这个库也会被称之为主库。但是如果写入性能要求高，可以调整为先写入内存数据库，再同步到持久化存储中。
线上数据访问，指根据ID或者其他的某个属性值来读取1-2条数据。一般不要直接从MySQL等持久化存储中出，需要采用couchbase，redis等内存数据库。
线上数据检索，检索和访问需要分开。按照关键字、时间等条件的检索，一般用Elastic来满足。
线上数据列表，如最新、最热、推荐等，都需要将数据预先计算好，放在couchbase或者redis等内存数据库中，读取的时候直接从库中出数据，不能执行实时计算。
通过这几个步骤，就可以优化线上服务的性能，最终呢，瓶颈应该不是在数据库或者CPU上，而是在带宽上。 那这就是砸钱的商务行为了。 这样处理，带来的最大的问题是空间浪费，是典型的以空间换时间的做法。 技术上的挑战，那就是数据一致性问题。 对于一致性要求不强的需求，这个做法是没问题的。 那如何在不同存储之间同步数据呢？主要的做法有：
使用数据库本身自带的同步机制。好处是一般不需要开发，问题是数据库的同步机制，如MysQL、HBase的replication机制，仅支持少数类型的备库，对数据库本身也有压力。
使用公共同步工具，如阿里的canal。
使用消息中间件来实现数据同步。
采用消息中间件目前主流的做法，适合于对数据实时性要求不高的场景。 如下图所示，在数据写入的服务中，完成写入后，抛出消息。其他数据库通过接受消息来更新数据。 优点是系统灵活，无论是同DC还是跨DC的情况都可以正常工作。 对数据同步的情况，可以通过MQ提供的监控系统也能够了解。 缺点是开发工作量大，数据同步实时性不高。 Image of Database Sync

如果时间不够
上述重构是非常理想的场景了，那如果时间不足，只能部分重构，应该如何处理？一种方式是针对DAO层来改进。 一般来说，重构往往意味着数据结构的变更。另一方面，由于数据写入的服务相对数据读取服务要少得多，所以可以采用的策略是：

调整DAO服务中数据写入操作，将数据写入到新的库表中；
采用MQ来实现新库表和老库表的数据同步。 参见上图。
老的DAO服务中数据读取的操作保持不变。
毕竟大部分的服务并不需要太高的性能需求。 只需要将性能要求高的服务进行重构，实现读写分离即可。重构方式如上描述。


一文简单描述了持续集成的所需要的基础软件。这里我们从软件过程的角度，详细介绍这些步骤。 支持持续集成所需要的基础软件，在该文中有介绍，请大家务必先阅读。 这里我们以基于jira的过程管理为例来讲述。 关于Jira软件本身介绍、相对Redmine的优势等问题，请大家自行查阅资料，不在本文介绍范围。 ·

从案例开始
支付系统开发过程有别于其它系统的要点在哪？就目前大部分公司而言，一般系统的开发人员是所谓的全栈工程师的:从写前后端代码，测试，上线到运维。线上出现bug，就登陆到服务器上翻日志，找原因，或者直接到数据库上改个数字。可这些行为，对支付系统来说，都是大忌。 介绍一个真实案例，某游戏公司的技术合伙人在开发时，将一些偏远省份的收单账户替换成自己账户。一年多时间无人发现。直到有一天一位投资者去某省出差，使用这个系统执行支付时候，发现收款公司名称与原公司略有不同。这位细心投资者让公司调查一下这事情，才发现其中的猫腻。

开发人员把某个收款账号替换成自己的账号怎么办？会不会修改数据库，把自己账号余额多加几个零？这些都是真实存在的问题，也都有人干过。虽然人与人之间的基本信任还是需要的，可是支付系统的基础向来都不是基于信任的，而是从各个角度来以最大的恶意来揣摩人性，从而出现可以被人利用的漏洞。 所以，对支付系统的开发，通俗的来说，有这个要求： 开发不上线；上线不开发。也就是开发人员不能参与上线和线上系统的运营。 那在这种情况下，如何保证开发的系统能够顺利上线，如何保证线上的系统在有问题的时候能够尽快被诊断出来并解决？ 这就需要一系列的基础设施的支持。

一、软件过程
Jira原是设计来进行Bug跟踪的系统，后来系统功能逐步完善后，被广泛适用于软件过程管理。Jira优势在于简单，好用。 这里就不介绍Jira的具体使用。 使用Jira进行软件项目管理，首先需要定义任务的处理流程。 以下是一个参考流程：
overview

在这个流程中，需要区分两个概念：任务和子任务。 每个任务对应一个完整的业务需求，比如对账、对接工行借记卡、获取个人优惠券列表接口。这些业务需求每个都是可以独立测试的。子任务设置相对比较简单，每个子任务对应这在本次任务执行中需要修改的开发项目。 比如对接工行借记卡，会涉及到：

支付网关项目调整；
支付路由项目中增加路由选项；
工行借记卡通道对接。
三个项目的修改，那会对应在这个任务下建立三个子任务。

任务是用来追踪项目过程的，这是项目经理和产品经理关注的层次。
子任务是用来支持开发自动化的，这是开发人员关注的层次。
这样，针对任务和子任务，会设置不同的属性：

task

1.1 需求管理
Jira也是一个不错的需求管理工具。产品经理可以通过Jira来执行需求管理，相对开发来说，需求管理流程会比较简单，一般是开发需求、审核需求、关闭需求三个环节即可。 需要注意的地方是：

需求管理流程需要和开发流程分离，毕竟这是不同的团队做的事情。
开发任务可以和需求任务相关联。Jira通过复制任务来提供这个支持。
一个需求任务可以对应多个开发任务，这在实际操作中是很常见的：

为了满足上线要求，一个需求任务会被拆分成多个开发任务，先完成核心功能开发并上线，再完成外围功能开发。这两次独立上线的工作，会被拆分为2个或者更多的开发任务；
如果对不同平台，比如Android，IOS，PCweb有不同的上线时间要求和技术需求，也需要将当前需求按照目标平台来拆分成开发任务。
1.2 创建任务
如上所述，开发任务的来源有两个：

需求任务，即对应产品经理提的需求
优化任务，这一般是开发团队内部进行重构或者性能优化来提的开发任务。
那任务的粒度如何把握？ 每个开发任务是一个完整的需求，是可以独立执行测试和验证的。 每个任务开发周期控制在1个月以内。

1.3 创建子任务
在接收到开发任务后，开发人员需要对系统实现进行设计和分解，确定需要新开发的内容以及需要改进的工作。 在微服务架构中，一次任务开发会涉及到多个系统的变更。这样就需要为每个系统建立一个独立的子任务，以后，我们将按照这个子任务的设置来驱动开发流程。 每个子任务开发周期尽量限制2天以内，不能超过一周。

1.4 启动主任务开发
主任务启动开发流程比较简单，主要是邮件通知到各相关人员，可以启动该任务。

1.5 启动子任务开发
子任务的启动和执行，是整个流程的核心工作。 启动子任务开发

这里如果是使用git/gitlab来做版本控制，整个流程的要点在于：

如果需要新建项目来开发，则由开发人员填写新项目的名称、类型（Web， RPC， 工具类等），在git上创建一个项目框架，包含必要的基础文件。
邮件通知开发人员需要下载的项目代码库地址。
开发人员签出代码到本地，执行开发工作。
开发人员随时可以签入代码到服务器上，发出Merge Request；
gitlab在接受签入前，执行静态代码检查。静态代码检查的工具有findbugs, PMD, Sonar等。 开发人员在开发时也必须自我进行静态检查，这里执行检查是避免开发人员漏查。
执行单元测试；
通知相关人员进行代码审核；
执行代码审核；
符合审核条件（如至少有2个人同意），审核通过， 代码被自动合并到主干版本。
通知子任务可以提测。 当然，是否提测，是由开发人员来决定。
1.6 子任务和任务提测
子任务开发完成后，即可提测。子任务提测时，将触发Jenkins进行测试环境部署。 测试有两种方式：自动测试和人工测试。尽量采用自动测试，使得开发人员能够及时发现问题。 所有子任务完成后，主任务可以提测。主任务提测后，如果是人工测试，则测试人员介入开始执行测试任务；如果是自动测试，则开始运行集成测试脚本。 提测 测试通过后， 既可以准备上线。

1.7 预部署和全部署
一般上线会分为两步，预部署和全部署。预部署的目的是先验证系统在线上环境运行是否正常，减少回滚成本。特别是在部署服务器特别多的情况下，先部署1-2台机器，可以在线上验证本次上线是否可以。 验证通过后，既可以执行全部署。 注意，预部署和全部署都是针对子任务而言。 上线 少数公司会要求上线前进行审批，但这样做是不利于流程自动化的。 一天几十次上线，谁能知道这是不是可以上。 但有一点很重要，系统上线前，必须通知到相关的使用方。如果出现问题，使用方可以尽快知悉。

二、项目文件结构
开发参考目录结构： 目录结构

从这个目录里面我们可以看到，和项目相关的部署用脚本，需要由项目开发人员自己来维护，用以保证部署工作能够自动执行。包括验证项目部署成功的脚本。 验证项目是否部署成功，一种方式是在日志中打桩，grep到这个日志，即意味着系统成功启动；一种方式是调用接口来验证是否成功。

部署目录参考：
目录结构

总之，微服务项目的管理核心理念在于“自动化”，消除人为因素。人管代码，代码管机器，最终目标是要实现自动上线。 消除人工测试，取代以自动化测试；消除人工验证，取代以自动验证；消除人工部署，取代以自动化部署。 这样，再多的项目，也能够很好的进行管理。